### 对于一个算法的优劣分析，从时间复杂度角度去考虑是十分恰当的。如果不通过理论计算，而是通过实际测试分析是不现实的，因为每台运行该算法的机器配置可能不尽相同。

**时间频度的概念：一个语句执行次数，记做T(n)**

很显然一条语句的执行次数越多，即T(n)越大，那么它花费的时间也就越多。
假设有一个函数f(n)与T(n)是等阶的函数，故T(n)/f(n)是一个常数（该常数可能会根据n的值变化而变化），不论两者有多大。
可以假设T(n)<=f(n)\*C     （C为两者商的最大常数）  
则可以假设一个映射关系T(n)=O(f(n)),在这里称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

常见的时间复杂度有 *常数阶、对数阶、线性阶、幂阶、指数阶、阶乘阶*

> 注：当n趋近于无穷的时候，低阶无穷大相对于高阶无穷大来说可以忽略。如 n^2+n 与 n^2等价，当n趋近无穷大时。

*求出算法中执行最多次数的语句的时间频率，就是该算法的时间复杂度*

多个时间复杂度计算时，类似于概率计算中的分部乘法和分类加法。

---

如
```python
if __name__ == "__main__":
	a = 1  # 执行最多的语句，时间频度度为1
	b = 2  # 执行最多的语句，时间频度度为1


```

时间复杂度为O(1)

---

```python

if __name__ == "__main__":
	a = 1 				
	for i in range(n):
		a+=1			# 执行最多的语句，时间频度为n

```
时间复杂度为O(n)

---

```python
	if __name__ == "__main__":

		a = 1  											

		for i in range(n):		

			for j in range(n):

				a+=1			# 执行最多的语句，时间频度为n^2
```
时间复杂度为O(n^2)

---

```python
	if __name__ == "__main__":

		i = 1

		while i<n:

			i*=2      #执行最多的语句，时间频度为以2为底，n的对数（2^i>=n)

```

时间复杂度为O(log₂n)
--- 
O(g(n))  上界：算法的执行时间小于此  存在一个数C 使得对所有的a>0 都有 f(n)<C*g(n),当n>a时，那么说f(n)属于O(g(n))    

Ω(g(n))  下界：算法的执行时间大于此  存在一个数C 使得对所有的a>0 都有 f(n)>C*g(n),当n>a时，那么说f(n)属于Ω(g(n))  

Θ(g(n))  紧界：算法的执行时间在此范围内  存在两个数C、D 使得对所有的a>0 都有 D*g(n)>f(n)>c*g(n),当n>a时，那么说f(n)属于Θ(g(n))  
